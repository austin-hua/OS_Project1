# Report

Group members: B06902101, B06902098	B05902099	B06902051	B05902132	B06902086

### Design
Our scheduler is in user space, so we need help from the Linux scheduler. The Linux scheduler provides a FIFO policy, processes under which has precedence over normal processes. Naturally, our scheduler and its children run under this policy, so other processes on the computer can't interfere with our processes. Processes have different priorities under FIFO policy, and those with a lower priority can't run if other processes with higher priorities are ready to run. We exploit this property to perform a context switch. Our main scheduler runs the process with the highest priority first and also makes sure there's always only one child (assuming the scheduler has at least one child) as the second highest priority, and the other children are in the lowest priority. When the scheduler blocks, the child with the highest priority gets the chance to run.

Our program can be split into three parts. One part is responsible for initialization, the next part is responsible for event handling, and the last part is responsible for job scheduling. There's nothing to say about initialization. After the initialization is the event handling part. It watches for events such as the arrival of new processes, time slice ending, or old process terminating. The first two events are handled using timers. It could be done by using two timers, but we chose to simulate two timers with one timer to practice our coding skills. All events generate signals, so a loop running sigsuspend() is an obvious choice. By only unblocking signals in sigsuspend(), and since the scheduler process has the highest priority, we make sure that there are no race conditions. After being notified an event, the event handler does some necessary work, such as resetting the timer or calling wait(), it tells job scheduler to handle the events. After that, the event handler checks whether there are incoming children or currently running children and if not, the event handler breaks from the loop.

The event handler notify an event to the job scheduler by calling add_process(), remove_current_process(), or timeslice_over(). Inside those functions is a switch statement that calls add_process_{policy}() or remove_current_process_{policy}(); depending on current policy. Since there may be multiple processes being added, the scheduler_empty_RR can't perform context switch yet. The event handler tells it it's time to perform context switch by calling context_switch_{policy}(). Another interface of the job scheduler is scheduler_empty_{policy}(), which is needed by the event handler to know whether it can stop waiting for events.

The FIFO scheduler does nearly nothing, as the scheduler and its children are already running under the kernel FIFO scheduler. All it does is remember how many children are running and tells the event handler whether there's still any child waiting to be scheduled. The RR scheduler uses an array to store process information and remembers which process to suspend and which process to continue. Both SJF scheduler and PSJF scheduler uses heap to manage jobs. In SJF scheduler, every job in the heap has never run. When the current job terminates, a new job is popped out and will never be pushed back. In PSJF scheduler, (TODO: I HAVE TO SLEEP, FINISH THIS PART LATER)

The design tries to separate concerns into different parts of the code, and each part of the code does not know each other too much. For example, the interface of job scheduler has very few parameters. remove_current_process() doesn't even require the caller to provide a ProcessInfo! Because even in theory the event handler can know which processes are terminated by pid, it's not really the event handler's business. The event handler doesn't try to provide the PSJF scheduler with any information about time—even if it can be useful—because the PSJF scheduler can figure that out by itself. Since the interface only requires minimum information and does not vary between policies, the event handling loop doesn't have to handle special cases. The only part that differs depending on policy is the timer part, as only RR requires an addtional timer. And that's because we try to simulate two timers with only one timer. The code can be even more elegant if we used two timers (which we obviously should, but that way it's less fun.)

Sadly, the abstraction still ends up being leaky. For example, it's not clear that which part of the code should be responsible for forking. The job scheduler should be the only one that sets the priority of children, but as we ended up letting event handler do fork, and after forking the priority should be set immediately, event handler also sets the priority of children. It's also not satisfactory that the event handler has to explicitly call context_switch().

### Contributions
Jason designed the program architecture, wrote the system calls and studied Linux FIFO scheduler.
Michael designed the timer.
Naveno and Seth designed the SJF and PSJF scheduling algorithms
Seth created the header file, added functions for debugging, input, and split the functions among several classes.
Shally and Ann Jee designed the RR and FIFO scheduling algorithms
